{"version":3,"file":"static/js/3639.15f313e1.chunk.js","mappings":"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","sources":["helpers/dataStructure.ts","models/worldMap.ts","pages/Blogs/Travel/WorldMap/hooks.ts","pages/Blogs/Travel/WorldMap/types.ts"],"sourcesContent":["export function arrayRepeat(arr: any[], length: number) {\n  return Array.from({ length }, () => arr).flat();\n}\n\nexport function isNullOrVoid(value: any) {\n  return value === null || value === undefined;\n}\n","import React from \"react\";\n\nimport {\n  T_SVGEventType,\n  T_ViewBoxProps\n} from \"pages/Blogs/Travel/WorldMap/types\";\n\n// This function returns an object with X & Y values from the pointer event\nexport function getPointFromEvent(event: T_SVGEventType) {\n  const point = { x: 0, y: 0 };\n  // If event is triggered by a touch event, we get the position of the first finger\n  if (isTouchEvent(event)) {\n    point.x = event.targetTouches[0].clientX;\n    point.y = event.targetTouches[0].clientY;\n  } else {\n    point.x = event.clientX;\n    point.y = event.clientY;\n  }\n\n  return point;\n}\n\nexport function getWidthRatio(\n  initialViewBox: T_ViewBoxProps,\n  svgRef: React.RefObject<SVGSVGElement>\n): number | void {\n  if (svgRef.current) {\n    return initialViewBox.width / svgRef.current.getBoundingClientRect().width;\n  }\n}\n\nfunction isTouchEvent(event: any): event is React.TouchEvent<SVGSVGElement> {\n  return !!event?.targetTouches;\n}\n","import { isNullOrVoid } from \"helpers/dataStructure\";\nimport { toNumber } from \"helpers/number\";\nimport { getPointFromEvent, getWidthRatio } from \"models/worldMap\";\nimport { useEffect, useMemo, useReducer, useRef } from \"react\";\nimport {\n  E_MapControlActions,\n  T_MapControlAction,\n  T_MapControlState,\n  T_SVGEventType\n} from \"./types\";\n\nconst initialViewBox = { x: 0, y: 0, width: 1010, height: 655 };\n\nexport function useMapControls() {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [state, dispatch] = useReducer(mapControlsReducer, {\n    initialViewBox,\n    viewBox: initialViewBox,\n    isPointerDown: false,\n    widthRatio: 1,\n    pointerOrigin: { x: 0, y: 0 },\n    zoomFactor: 1\n  });\n  const panEventHandlers = usePanEventHandlers(dispatch);\n  const zoomEventHandlers = useZoomEventHandlers(dispatch);\n  useWidthRatioCalculator(dispatch, svgRef);\n\n  return {\n    ...state,\n    svgRef,\n    panEventHandlers,\n    zoomEventHandlers\n  };\n}\n\nfunction usePanEventHandlers(dispatch: React.Dispatch<T_MapControlAction>) {\n  // return useMemo(() => {\n  const onPointerDown = (event: T_SVGEventType) => {\n    const pointerPosition = getPointFromEvent(event);\n    dispatch([E_MapControlActions.pointerDown, pointerPosition]);\n  };\n  const onPointerUp = () => {\n    dispatch([E_MapControlActions.pointerUp]);\n  };\n  const onPointerMove = (event: T_SVGEventType) => {\n    // This prevent user to do a selection on the page\n    event.preventDefault();\n    // Get the pointer position\n    const pointerPosition = getPointFromEvent(event);\n    dispatch([E_MapControlActions.pointerMove, pointerPosition]);\n  };\n\n  // If browser supports pointer events\n  if (window.PointerEvent) {\n    return {\n      onPointerDown,\n      onPointerUp,\n      onPointerLeave: onPointerUp,\n      onPointerMove\n    };\n  } else {\n    return {\n      // Add all mouse events listeners fallback\n      onMouseDown: onPointerDown,\n      onMouseUp: onPointerUp,\n      onMouseLeave: onPointerUp,\n      onMouseMove: onPointerMove,\n      // Add all touch events listeners fallback\n      onTouchStart: onPointerDown,\n      onTouchEnd: onPointerUp,\n      onTouchCancel: onPointerUp,\n      onTouchMove: onPointerMove\n    };\n  }\n  // }, [dispatch]);\n}\n\nfunction useZoomEventHandlers(dispatch: React.Dispatch<T_MapControlAction>) {\n  return {\n    zoomIn: () => dispatch([E_MapControlActions.zoomIn]),\n    zoomOut: () => dispatch([E_MapControlActions.zoomOut]),\n    zoomReset: () => dispatch([E_MapControlActions.zoomReset])\n  };\n}\n\nfunction useWidthRatioCalculator(\n  dispatch: React.Dispatch<T_MapControlAction>,\n  svgRef: React.RefObject<SVGSVGElement>\n) {\n  useEffect(() => {\n    const onResize = () => {\n      const widthRatio = getWidthRatio(initialViewBox, svgRef);\n      if (!isNullOrVoid(widthRatio)) {\n        dispatch([E_MapControlActions.setWidthRatio, widthRatio]);\n      }\n    };\n\n    // Calculate once the ratio based on the viewBox width and the SVG width\n    onResize();\n    // and then listen for any changes\n    window.addEventListener(\"resize\", onResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", onResize);\n    };\n  }, [svgRef, dispatch]);\n}\n\nconst zoomFactorStep = 0.2;\n\nfunction mapControlsReducer(\n  state: T_MapControlState,\n  [type, payload]: T_MapControlAction\n): T_MapControlState {\n  switch (type) {\n    case E_MapControlActions.setWidthRatio: {\n      return {\n        ...state,\n        widthRatio: payload\n      };\n    }\n    case E_MapControlActions.pointerDown: {\n      return {\n        ...state,\n        isPointerDown: true,\n        // We save the pointer position on click/touchdown\n        // so we can get the value once the user starts to drag\n        pointerOrigin: payload\n      };\n    }\n    case E_MapControlActions.pointerMove: {\n      // Only recompute state if the pointer is down\n      if (!state.isPointerDown) {\n        return state;\n      }\n\n      return {\n        ...state,\n        viewBox: {\n          ...state.viewBox,\n          // We calculate the distance between the pointer origin and the current position\n          // The viewBox x & y values must be calculated from the original values and the distances\n          x:\n            state.initialViewBox.x -\n            (payload.x - state.pointerOrigin.x) * state.widthRatio,\n          y:\n            state.initialViewBox.y -\n            (payload.y - state.pointerOrigin.y) * state.widthRatio\n        }\n      };\n    }\n    case E_MapControlActions.pointerUp: {\n      return {\n        ...state,\n        // The pointer is no longer considered as down\n        isPointerDown: false,\n        initialViewBox: {\n          ...state.initialViewBox,\n          // We save the viewBox coordinates based on the last pointer offsets\n          // This step is important because otherwise we would always calculate\n          // the pointer offsets from the original viewBox values and the user\n          // will drag the SVG from the starting point every time.\n          x: state.viewBox.x,\n          y: state.viewBox.y\n        }\n      };\n    }\n    case E_MapControlActions.zoomIn: {\n      return {\n        ...state,\n        zoomFactor: state.zoomFactor + zoomFactorStep\n      };\n    }\n    case E_MapControlActions.zoomOut: {\n      return {\n        ...state,\n        zoomFactor: state.zoomFactor - zoomFactorStep\n      };\n    }\n    case E_MapControlActions.zoomReset: {\n      return {\n        ...state,\n        zoomFactor: 1\n      };\n    }\n    default:\n      return state;\n  }\n}\n","export enum E_MapControlActions {\n  setWidthRatio,\n  pointerDown,\n  pointerUp,\n  pointerMove,\n  zoomIn,\n  zoomOut,\n  zoomReset\n}\n\nexport type T_ViewBoxProps = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\nexport type T_MapControlState = {\n  zoomFactor: number;\n  widthRatio: number;\n  initialViewBox: T_ViewBoxProps;\n  viewBox: T_ViewBoxProps;\n  // for move events to check if pointer is down or not\n  isPointerDown: boolean;\n  // contains the original coordinates when the user start\n  // pressing the mouse or touching the screen\n  pointerOrigin: { x: number; y: number };\n};\n\nexport type T_SVGEventType =\n  | React.MouseEvent<SVGSVGElement, MouseEvent>\n  | React.TouchEvent<SVGSVGElement>;\n\nexport type T_MapControlAction = [type: E_MapControlActions, payload?: any];\n"],"names":["arrayRepeat","arr","length","Array","from","flat","isNullOrVoid","value","undefined","getPointFromEvent","event","point","x","y","targetTouches","isTouchEvent","clientX","clientY","getWidthRatio","initialViewBox","svgRef","current","width","getBoundingClientRect","height","useMapControls","useRef","useReducer","mapControlsReducer","viewBox","isPointerDown","widthRatio","pointerOrigin","zoomFactor","state","dispatch","panEventHandlers","onPointerDown","pointerPosition","E_MapControlActions","onPointerUp","onPointerMove","preventDefault","window","PointerEvent","onPointerLeave","onMouseDown","onMouseUp","onMouseLeave","onMouseMove","onTouchStart","onTouchEnd","onTouchCancel","onTouchMove","usePanEventHandlers","zoomEventHandlers","zoomIn","zoomOut","zoomReset","useZoomEventHandlers","useEffect","onResize","addEventListener","removeEventListener","useWidthRatioCalculator","type","payload"],"sourceRoot":""}