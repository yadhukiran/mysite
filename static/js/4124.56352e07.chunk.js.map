{"version":3,"file":"static/js/4124.56352e07.chunk.js","mappings":"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","sources":["pages/blogs/travel/worldmap/hooks.ts","pages/blogs/travel/worldmap/models.ts","pages/blogs/travel/worldmap/types.ts"],"sourcesContent":["import { isNullOrVoid } from \"shared/helpers/dataStructure\";\nimport {\n  getCompensatoryTranslationForZoom,\n  getElementRectMidPoint,\n  getElementTitleFromPoint,\n  getPointFromEvent,\n  getWidthRatio\n} from \"./models\";\nimport { useEffect, useReducer, useRef } from \"react\";\nimport { T_Nullable } from \"shared/types/generic\";\nimport {\n  E_MapControlActions,\n  T_GeometricInitials,\n  T_MapControlAction,\n  T_MapControlState,\n  T_PointedAt,\n  T_SVGEventType,\n  T_ViewBoxProps\n} from \"./types\";\n\nconst originCoordinates = { x: 0, y: 0 };\nconst initialViewBox: T_ViewBoxProps = {\n  ...originCoordinates,\n  width: 1010,\n  height: 655\n};\nconst initialPointedAt: T_Nullable<T_PointedAt> = null;\nconst initialZoomFactor = 1;\nconst initialWidthRatio = 1;\n\nexport function useMapControls() {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [state, dispatch] = useReducer(mapControlsReducer, {\n    pointedAt: initialPointedAt,\n    initialViewBox,\n    viewBox: initialViewBox,\n    isPointerDown: false,\n    widthRatio: initialWidthRatio,\n    pointerOrigin: originCoordinates,\n    zoomCompensatoryTranslate: originCoordinates,\n    zoomFactor: initialZoomFactor\n  });\n  const panEventHandlers = usePanEventHandlers(dispatch, svgRef);\n  const zoomEventHandlers = useZoomEventHandlers(dispatch, svgRef);\n  useGeometry(dispatch, svgRef);\n\n  return {\n    ...state,\n    svgRef,\n    panEventHandlers,\n    zoomEventHandlers\n  };\n}\n\nfunction usePanEventHandlers(\n  dispatch: React.Dispatch<T_MapControlAction>,\n  svgRef: React.RefObject<SVGSVGElement>\n) {\n  // return useMemo(() => {\n  const onPointerDown = (event: T_SVGEventType) => {\n    const pointerPosition = getPointFromEvent(event);\n    dispatch([E_MapControlActions.pointerDown, pointerPosition]);\n  };\n  const onPointerUp = () => {\n    dispatch([E_MapControlActions.pointerUp]);\n  };\n  const onPointerMove = (event: T_SVGEventType) => {\n    // This prevent user to do a selection on the page\n    event.preventDefault();\n    // Get the pointer position\n    const pointerPosition = getPointFromEvent(event);\n    const elementTitle = getElementTitleFromPoint(pointerPosition);\n\n    dispatch([\n      E_MapControlActions.pointerMove,\n      { elementTitle, position: pointerPosition }\n    ]);\n  };\n\n  // If browser supports pointer events\n  if (window.PointerEvent) {\n    return {\n      onPointerDown,\n      onPointerUp,\n      onPointerLeave: onPointerUp,\n      onPointerMove\n    };\n  } else {\n    return {\n      // Add all mouse events listeners fallback\n      onMouseDown: onPointerDown,\n      onMouseUp: onPointerUp,\n      onMouseLeave: onPointerUp,\n      onMouseMove: onPointerMove,\n      // Add all touch events listeners fallback\n      onTouchStart: onPointerDown,\n      onTouchEnd: onPointerUp,\n      onTouchMove: onPointerMove\n    };\n  }\n  // }, [dispatch]);\n}\n\nfunction useZoomEventHandlers(\n  dispatch: React.Dispatch<T_MapControlAction>,\n  svgRef: React.RefObject<SVGSVGElement>\n) {\n  return {\n    zoomIn: () => dispatch([E_MapControlActions.zoomIn]),\n    zoomOut: () => dispatch([E_MapControlActions.zoomOut]),\n    zoomReset: () => dispatch([E_MapControlActions.zoomReset])\n  };\n}\n\nfunction useGeometry(\n  dispatch: React.Dispatch<T_MapControlAction>,\n  svgRef: React.RefObject<SVGSVGElement>\n) {\n  useEffect(() => {\n    const onResize = () => {\n      const geometricInitials = {} as T_GeometricInitials;\n      const midPoint = getElementRectMidPoint(svgRef);\n      const widthRatio = getWidthRatio(initialViewBox, svgRef);\n\n      if (!isNullOrVoid(widthRatio)) {\n        geometricInitials.widthRatio = widthRatio;\n      }\n      if (midPoint) {\n        geometricInitials.midPoint = midPoint;\n      }\n\n      if (Object.keys(geometricInitials).length > 0) {\n        dispatch([E_MapControlActions.setGeometricInitials, geometricInitials]);\n      }\n    };\n\n    // Calculate once the ratio based on the viewBox width and the SVG width\n    onResize();\n    // and then listen for any changes\n    window.addEventListener(\"resize\", onResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", onResize);\n    };\n  }, [svgRef, dispatch]);\n}\n\nconst zoomFactorStep = 0.5;\n\nfunction mapControlsReducer(\n  state: T_MapControlState,\n  [type, payload]: T_MapControlAction\n): T_MapControlState {\n  switch (type) {\n    case E_MapControlActions.setGeometricInitials: {\n      return {\n        ...state,\n        ...payload\n      };\n    }\n    case E_MapControlActions.pointerDown: {\n      return {\n        ...state,\n        isPointerDown: true,\n        // We save the pointer position on click/touchdown\n        // so we can get the value once the user starts to drag\n        pointerOrigin: payload\n      };\n    }\n    case E_MapControlActions.pointerMove: {\n      const isPointedAtRelevant = !!payload.elementTitle;\n      const newPointedAt = isPointedAtRelevant ? payload : initialPointedAt;\n\n      // Only recompute view box positions if the pointer is down\n      if (!state.isPointerDown) {\n        // Even if pointer is not down, we may still need to update state.pointedAt\n        // user moves the pointer. However, we shall update state only if:\n        //  - new value of 'pointedAt' corresponds to a relevant element OR\n        //  - we need to reset state.pointedAt (when user points to a irrelevant element)\n        if (isPointedAtRelevant || state.pointedAt !== initialPointedAt) {\n          return { ...state, pointedAt: newPointedAt };\n        }\n\n        return state;\n      }\n\n      return {\n        ...state,\n        // Do not show element title while panning\n        pointedAt: initialPointedAt,\n        viewBox: {\n          ...state.viewBox,\n          // We calculate the distance between the pointer origin and the current position\n          // The viewBox x & y values must be calculated from the original values and the distances\n          x:\n            state.initialViewBox.x -\n            (payload.position.x - state.pointerOrigin.x) * state.widthRatio,\n          y:\n            state.initialViewBox.y -\n            (payload.position.y - state.pointerOrigin.y) * state.widthRatio\n        }\n      };\n    }\n    case E_MapControlActions.pointerUp: {\n      return {\n        ...state,\n        // The pointer is no longer considered as down\n        isPointerDown: false,\n        initialViewBox: {\n          ...state.initialViewBox,\n          // We save the viewBox coordinates based on the last pointer offsets\n          // This step is important because otherwise we would always calculate\n          // the pointer offsets from the original viewBox values and the user\n          // will drag the SVG from the starting point every time.\n          x: state.viewBox.x,\n          y: state.viewBox.y\n        }\n      };\n    }\n    case E_MapControlActions.zoomIn: {\n      const newZoomFactor = state.zoomFactor + zoomFactorStep;\n      let newTranslation;\n      if (state.midPoint) {\n        newTranslation = getCompensatoryTranslationForZoom(\n          state.midPoint,\n          newZoomFactor\n        );\n      }\n\n      return {\n        ...state,\n        zoomFactor: newZoomFactor,\n        zoomCompensatoryTranslate:\n          newTranslation ?? state.zoomCompensatoryTranslate\n      };\n    }\n    case E_MapControlActions.zoomOut: {\n      const newZoomFactor = state.zoomFactor - zoomFactorStep;\n      let newTranslation;\n      if (state.midPoint) {\n        newTranslation = getCompensatoryTranslationForZoom(\n          state.midPoint,\n          newZoomFactor\n        );\n      }\n\n      if (newZoomFactor > 1 || state.zoomFactor !== initialZoomFactor) {\n        return {\n          ...state,\n          zoomFactor:\n            newZoomFactor < initialZoomFactor\n              ? initialZoomFactor\n              : newZoomFactor,\n          zoomCompensatoryTranslate:\n            newTranslation ?? state.zoomCompensatoryTranslate\n        };\n      }\n\n      return state;\n    }\n    case E_MapControlActions.zoomReset: {\n      return {\n        ...state,\n        zoomFactor: initialZoomFactor,\n        zoomCompensatoryTranslate: originCoordinates,\n        viewBox: initialViewBox,\n        initialViewBox: initialViewBox\n      };\n    }\n    default:\n      return state;\n  }\n}\n","import React from \"react\";\n\nimport {\n  T_Coordinates,\n  T_SVGEventType,\n  T_ViewBoxProps\n} from \"pages/blogs/travel/worldmap/types\";\n\nexport function getCompensatoryTranslationForZoom(\n  zoomPoint: T_Coordinates,\n  zoomFactor: number\n): T_Coordinates {\n  return {\n    x: -(zoomPoint.x * (zoomFactor - 1)) / zoomFactor,\n    y: -(zoomPoint.y * (zoomFactor - 1)) / zoomFactor\n  };\n}\n\n// This function returns an object with X & Y values from the pointer event\nexport function getPointFromEvent(event: T_SVGEventType): T_Coordinates {\n  const point = { x: 0, y: 0 };\n  // If event is triggered by a touch event, we get the position of the first finger\n  if (isTouchEvent(event)) {\n    point.x = event.targetTouches[0].clientX;\n    point.y = event.targetTouches[0].clientY;\n  } else {\n    point.x = event.clientX;\n    point.y = event.clientY;\n  }\n\n  return point;\n}\n\nexport function getElementRectMidPoint(\n  svgRef: React.RefObject<SVGSVGElement>\n): T_Coordinates | void {\n  if (svgRef.current) {\n    return {\n      x: svgRef.current.getBoundingClientRect().width / 2,\n      y: svgRef.current.getBoundingClientRect().height / 2\n    };\n  }\n}\n\nexport function getWidthRatio(\n  initialViewBox: T_ViewBoxProps,\n  svgRef: React.RefObject<SVGSVGElement>\n): number | void {\n  if (svgRef.current) {\n    return initialViewBox.width / svgRef.current.getBoundingClientRect().width;\n  }\n}\n\nexport function getElementTitleFromPoint(position: T_Coordinates): string {\n  const element = document.elementFromPoint(position.x, position.y);\n\n  if (element) {\n    const dataObj = (element as any).dataset || element;\n    return dataObj.title ?? dataObj.id;\n  }\n\n  return \"\";\n}\n\nfunction isTouchEvent(event: any): event is React.TouchEvent<SVGSVGElement> {\n  return !!event?.targetTouches;\n}\n","import { T_Nullable } from \"shared/types/generic\";\n\nexport enum E_MapControlActions {\n  setGeometricInitials,\n  pointerDown,\n  pointerUp,\n  pointerMove,\n  zoomIn,\n  zoomOut,\n  zoomReset\n}\n\nexport type T_ViewBoxProps = T_Coordinates & {\n  width: number;\n  height: number;\n};\n\nexport type T_MapControlState = {\n  zoomFactor: number;\n  zoomCompensatoryTranslate: T_Coordinates;\n  widthRatio: number;\n  initialViewBox: T_ViewBoxProps;\n  viewBox: T_ViewBoxProps;\n  // for move events to check if pointer is down or not\n  isPointerDown: boolean;\n  // contains the original coordinates when the user start\n  // pressing the mouse or touching the screen\n  pointerOrigin: T_Coordinates;\n  midPoint?: T_Coordinates;\n  pointedAt: T_Nullable<T_PointedAt>;\n};\n\nexport type T_Coordinates = { x: number; y: number };\nexport type T_GeometricInitials = Partial<{\n  midPoint: T_Coordinates;\n  widthRatio: number;\n}>;\n\nexport type T_SVGEventType =\n  | React.MouseEvent<SVGSVGElement, MouseEvent>\n  | React.TouchEvent<SVGSVGElement>;\n\nexport type T_MapControlAction = [type: E_MapControlActions, payload?: any];\n// TODO: Elaborate action types: VS code is able to understand them, but CRA is not\n// export type T_MapControlAction =\n//   | [\n//       type: E_MapControlActions.setGeometricInitials,\n//       payload: T_GeometricInitials\n//     ]\n//   | [type: E_MapControlActions.pointerDown, payload: T_Coordinates]\n//   | [type: E_MapControlActions.pointerMove, payload: T_PointedAt]\n//   | [type: E_MapControlActions.pointerUp]\n//   | [type: E_MapControlActions.zoomIn]\n//   | [type: E_MapControlActions.zoomOut]\n//   | [type: E_MapControlActions.zoomReset];\n\nexport type T_PointedAt = {\n  elementTitle?: string;\n  position: T_Coordinates;\n};\n"],"names":["originCoordinates","x","y","initialViewBox","width","height","initialPointedAt","useMapControls","svgRef","useRef","useReducer","mapControlsReducer","pointedAt","viewBox","isPointerDown","widthRatio","pointerOrigin","zoomCompensatoryTranslate","zoomFactor","state","dispatch","panEventHandlers","onPointerDown","event","pointerPosition","getPointFromEvent","E_MapControlActions","onPointerUp","onPointerMove","preventDefault","elementTitle","getElementTitleFromPoint","position","window","PointerEvent","onPointerLeave","onMouseDown","onMouseUp","onMouseLeave","onMouseMove","onTouchStart","onTouchEnd","onTouchMove","usePanEventHandlers","zoomEventHandlers","zoomIn","zoomOut","zoomReset","useZoomEventHandlers","useEffect","onResize","geometricInitials","midPoint","getElementRectMidPoint","getWidthRatio","isNullOrVoid","Object","keys","length","addEventListener","removeEventListener","useGeometry","type","payload","isPointedAtRelevant","newPointedAt","newTranslation","newZoomFactor","getCompensatoryTranslationForZoom","zoomPoint","point","targetTouches","isTouchEvent","clientX","clientY","current","getBoundingClientRect","element","document","elementFromPoint","dataObj","dataset","title","id"],"sourceRoot":""}